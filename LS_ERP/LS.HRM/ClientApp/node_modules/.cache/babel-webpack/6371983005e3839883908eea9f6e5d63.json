{"ast":null,"code":"import * as English from \"./english.js\";\nimport * as Formats from \"./formats.js\";\nimport { padStart } from \"./util.js\";\n\nfunction stringifyTokens(splits, tokenToString) {\n  let s = \"\";\n\n  for (const token of splits) {\n    if (token.literal) {\n      s += token.val;\n    } else {\n      s += tokenToString(token.val);\n    }\n  }\n\n  return s;\n}\n\nconst macroTokenToFormatOpts = {\n  D: Formats.DATE_SHORT,\n  DD: Formats.DATE_MED,\n  DDD: Formats.DATE_FULL,\n  DDDD: Formats.DATE_HUGE,\n  t: Formats.TIME_SIMPLE,\n  tt: Formats.TIME_WITH_SECONDS,\n  ttt: Formats.TIME_WITH_SHORT_OFFSET,\n  tttt: Formats.TIME_WITH_LONG_OFFSET,\n  T: Formats.TIME_24_SIMPLE,\n  TT: Formats.TIME_24_WITH_SECONDS,\n  TTT: Formats.TIME_24_WITH_SHORT_OFFSET,\n  TTTT: Formats.TIME_24_WITH_LONG_OFFSET,\n  f: Formats.DATETIME_SHORT,\n  ff: Formats.DATETIME_MED,\n  fff: Formats.DATETIME_FULL,\n  ffff: Formats.DATETIME_HUGE,\n  F: Formats.DATETIME_SHORT_WITH_SECONDS,\n  FF: Formats.DATETIME_MED_WITH_SECONDS,\n  FFF: Formats.DATETIME_FULL_WITH_SECONDS,\n  FFFF: Formats.DATETIME_HUGE_WITH_SECONDS\n};\n/**\r\n * @private\r\n */\n\nexport default class Formatter {\n  static create(locale, opts = {}) {\n    return new Formatter(locale, opts);\n  }\n\n  static parseFormat(fmt) {\n    // white-space is always considered a literal in user-provided formats\n    // the \" \" token has a special meaning (see unitForToken)\n    let current = null,\n        currentFull = \"\",\n        bracketed = false;\n    const splits = [];\n\n    for (let i = 0; i < fmt.length; i++) {\n      const c = fmt.charAt(i);\n\n      if (c === \"'\") {\n        if (currentFull.length > 0) {\n          splits.push({\n            literal: bracketed || /^\\s+$/.test(currentFull),\n            val: currentFull\n          });\n        }\n\n        current = null;\n        currentFull = \"\";\n        bracketed = !bracketed;\n      } else if (bracketed) {\n        currentFull += c;\n      } else if (c === current) {\n        currentFull += c;\n      } else {\n        if (currentFull.length > 0) {\n          splits.push({\n            literal: /^\\s+$/.test(currentFull),\n            val: currentFull\n          });\n        }\n\n        currentFull = c;\n        current = c;\n      }\n    }\n\n    if (currentFull.length > 0) {\n      splits.push({\n        literal: bracketed || /^\\s+$/.test(currentFull),\n        val: currentFull\n      });\n    }\n\n    return splits;\n  }\n\n  static macroTokenToFormatOpts(token) {\n    return macroTokenToFormatOpts[token];\n  }\n\n  constructor(locale, formatOpts) {\n    this.opts = formatOpts;\n    this.loc = locale;\n    this.systemLoc = null;\n  }\n\n  formatWithSystemDefault(dt, opts) {\n    if (this.systemLoc === null) {\n      this.systemLoc = this.loc.redefaultToSystem();\n    }\n\n    const df = this.systemLoc.dtFormatter(dt, { ...this.opts,\n      ...opts\n    });\n    return df.format();\n  }\n\n  formatDateTime(dt, opts = {}) {\n    const df = this.loc.dtFormatter(dt, { ...this.opts,\n      ...opts\n    });\n    return df.format();\n  }\n\n  formatDateTimeParts(dt, opts = {}) {\n    const df = this.loc.dtFormatter(dt, { ...this.opts,\n      ...opts\n    });\n    return df.formatToParts();\n  }\n\n  formatInterval(interval, opts = {}) {\n    const df = this.loc.dtFormatter(interval.start, { ...this.opts,\n      ...opts\n    });\n    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());\n  }\n\n  resolvedOptions(dt, opts = {}) {\n    const df = this.loc.dtFormatter(dt, { ...this.opts,\n      ...opts\n    });\n    return df.resolvedOptions();\n  }\n\n  num(n, p = 0) {\n    // we get some perf out of doing this here, annoyingly\n    if (this.opts.forceSimple) {\n      return padStart(n, p);\n    }\n\n    const opts = { ...this.opts\n    };\n\n    if (p > 0) {\n      opts.padTo = p;\n    }\n\n    return this.loc.numberFormatter(opts).format(n);\n  }\n\n  formatDateTimeFromString(dt, fmt) {\n    const knownEnglish = this.loc.listingMode() === \"en\",\n          useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== \"gregory\",\n          string = (opts, extract) => this.loc.extract(dt, opts, extract),\n          formatOffset = opts => {\n      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {\n        return \"Z\";\n      }\n\n      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : \"\";\n    },\n          meridiem = () => knownEnglish ? English.meridiemForDateTime(dt) : string({\n      hour: \"numeric\",\n      hourCycle: \"h12\"\n    }, \"dayperiod\"),\n          month = (length, standalone) => knownEnglish ? English.monthForDateTime(dt, length) : string(standalone ? {\n      month: length\n    } : {\n      month: length,\n      day: \"numeric\"\n    }, \"month\"),\n          weekday = (length, standalone) => knownEnglish ? English.weekdayForDateTime(dt, length) : string(standalone ? {\n      weekday: length\n    } : {\n      weekday: length,\n      month: \"long\",\n      day: \"numeric\"\n    }, \"weekday\"),\n          maybeMacro = token => {\n      const formatOpts = Formatter.macroTokenToFormatOpts(token);\n\n      if (formatOpts) {\n        return this.formatWithSystemDefault(dt, formatOpts);\n      } else {\n        return token;\n      }\n    },\n          era = length => knownEnglish ? English.eraForDateTime(dt, length) : string({\n      era: length\n    }, \"era\"),\n          tokenToString = token => {\n      // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles\n      switch (token) {\n        // ms\n        case \"S\":\n          return this.num(dt.millisecond);\n\n        case \"u\": // falls through\n\n        case \"SSS\":\n          return this.num(dt.millisecond, 3);\n        // seconds\n\n        case \"s\":\n          return this.num(dt.second);\n\n        case \"ss\":\n          return this.num(dt.second, 2);\n        // fractional seconds\n\n        case \"uu\":\n          return this.num(Math.floor(dt.millisecond / 10), 2);\n\n        case \"uuu\":\n          return this.num(Math.floor(dt.millisecond / 100));\n        // minutes\n\n        case \"m\":\n          return this.num(dt.minute);\n\n        case \"mm\":\n          return this.num(dt.minute, 2);\n        // hours\n\n        case \"h\":\n          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);\n\n        case \"hh\":\n          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);\n\n        case \"H\":\n          return this.num(dt.hour);\n\n        case \"HH\":\n          return this.num(dt.hour, 2);\n        // offset\n\n        case \"Z\":\n          // like +6\n          return formatOffset({\n            format: \"narrow\",\n            allowZ: this.opts.allowZ\n          });\n\n        case \"ZZ\":\n          // like +06:00\n          return formatOffset({\n            format: \"short\",\n            allowZ: this.opts.allowZ\n          });\n\n        case \"ZZZ\":\n          // like +0600\n          return formatOffset({\n            format: \"techie\",\n            allowZ: this.opts.allowZ\n          });\n\n        case \"ZZZZ\":\n          // like EST\n          return dt.zone.offsetName(dt.ts, {\n            format: \"short\",\n            locale: this.loc.locale\n          });\n\n        case \"ZZZZZ\":\n          // like Eastern Standard Time\n          return dt.zone.offsetName(dt.ts, {\n            format: \"long\",\n            locale: this.loc.locale\n          });\n        // zone\n\n        case \"z\":\n          // like America/New_York\n          return dt.zoneName;\n        // meridiems\n\n        case \"a\":\n          return meridiem();\n        // dates\n\n        case \"d\":\n          return useDateTimeFormatter ? string({\n            day: \"numeric\"\n          }, \"day\") : this.num(dt.day);\n\n        case \"dd\":\n          return useDateTimeFormatter ? string({\n            day: \"2-digit\"\n          }, \"day\") : this.num(dt.day, 2);\n        // weekdays - standalone\n\n        case \"c\":\n          // like 1\n          return this.num(dt.weekday);\n\n        case \"ccc\":\n          // like 'Tues'\n          return weekday(\"short\", true);\n\n        case \"cccc\":\n          // like 'Tuesday'\n          return weekday(\"long\", true);\n\n        case \"ccccc\":\n          // like 'T'\n          return weekday(\"narrow\", true);\n        // weekdays - format\n\n        case \"E\":\n          // like 1\n          return this.num(dt.weekday);\n\n        case \"EEE\":\n          // like 'Tues'\n          return weekday(\"short\", false);\n\n        case \"EEEE\":\n          // like 'Tuesday'\n          return weekday(\"long\", false);\n\n        case \"EEEEE\":\n          // like 'T'\n          return weekday(\"narrow\", false);\n        // months - standalone\n\n        case \"L\":\n          // like 1\n          return useDateTimeFormatter ? string({\n            month: \"numeric\",\n            day: \"numeric\"\n          }, \"month\") : this.num(dt.month);\n\n        case \"LL\":\n          // like 01, doesn't seem to work\n          return useDateTimeFormatter ? string({\n            month: \"2-digit\",\n            day: \"numeric\"\n          }, \"month\") : this.num(dt.month, 2);\n\n        case \"LLL\":\n          // like Jan\n          return month(\"short\", true);\n\n        case \"LLLL\":\n          // like January\n          return month(\"long\", true);\n\n        case \"LLLLL\":\n          // like J\n          return month(\"narrow\", true);\n        // months - format\n\n        case \"M\":\n          // like 1\n          return useDateTimeFormatter ? string({\n            month: \"numeric\"\n          }, \"month\") : this.num(dt.month);\n\n        case \"MM\":\n          // like 01\n          return useDateTimeFormatter ? string({\n            month: \"2-digit\"\n          }, \"month\") : this.num(dt.month, 2);\n\n        case \"MMM\":\n          // like Jan\n          return month(\"short\", false);\n\n        case \"MMMM\":\n          // like January\n          return month(\"long\", false);\n\n        case \"MMMMM\":\n          // like J\n          return month(\"narrow\", false);\n        // years\n\n        case \"y\":\n          // like 2014\n          return useDateTimeFormatter ? string({\n            year: \"numeric\"\n          }, \"year\") : this.num(dt.year);\n\n        case \"yy\":\n          // like 14\n          return useDateTimeFormatter ? string({\n            year: \"2-digit\"\n          }, \"year\") : this.num(dt.year.toString().slice(-2), 2);\n\n        case \"yyyy\":\n          // like 0012\n          return useDateTimeFormatter ? string({\n            year: \"numeric\"\n          }, \"year\") : this.num(dt.year, 4);\n\n        case \"yyyyyy\":\n          // like 000012\n          return useDateTimeFormatter ? string({\n            year: \"numeric\"\n          }, \"year\") : this.num(dt.year, 6);\n        // eras\n\n        case \"G\":\n          // like AD\n          return era(\"short\");\n\n        case \"GG\":\n          // like Anno Domini\n          return era(\"long\");\n\n        case \"GGGGG\":\n          return era(\"narrow\");\n\n        case \"kk\":\n          return this.num(dt.weekYear.toString().slice(-2), 2);\n\n        case \"kkkk\":\n          return this.num(dt.weekYear, 4);\n\n        case \"W\":\n          return this.num(dt.weekNumber);\n\n        case \"WW\":\n          return this.num(dt.weekNumber, 2);\n\n        case \"o\":\n          return this.num(dt.ordinal);\n\n        case \"ooo\":\n          return this.num(dt.ordinal, 3);\n\n        case \"q\":\n          // like 1\n          return this.num(dt.quarter);\n\n        case \"qq\":\n          // like 01\n          return this.num(dt.quarter, 2);\n\n        case \"X\":\n          return this.num(Math.floor(dt.ts / 1000));\n\n        case \"x\":\n          return this.num(dt.ts);\n\n        default:\n          return maybeMacro(token);\n      }\n    };\n\n    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);\n  }\n\n  formatDurationFromString(dur, fmt) {\n    const tokenToField = token => {\n      switch (token[0]) {\n        case \"S\":\n          return \"millisecond\";\n\n        case \"s\":\n          return \"second\";\n\n        case \"m\":\n          return \"minute\";\n\n        case \"h\":\n          return \"hour\";\n\n        case \"d\":\n          return \"day\";\n\n        case \"w\":\n          return \"week\";\n\n        case \"M\":\n          return \"month\";\n\n        case \"y\":\n          return \"year\";\n\n        default:\n          return null;\n      }\n    },\n          tokenToString = lildur => token => {\n      const mapped = tokenToField(token);\n\n      if (mapped) {\n        return this.num(lildur.get(mapped), token.length);\n      } else {\n        return token;\n      }\n    },\n          tokens = Formatter.parseFormat(fmt),\n          realTokens = tokens.reduce((found, {\n      literal,\n      val\n    }) => literal ? found : found.concat(val), []),\n          collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter(t => t));\n\n    return stringifyTokens(tokens, tokenToString(collapsed));\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}
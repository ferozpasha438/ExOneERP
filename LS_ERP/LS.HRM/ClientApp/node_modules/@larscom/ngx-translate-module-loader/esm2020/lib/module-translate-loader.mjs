import { all as mergeAll } from 'deepmerge';
import { forkJoin as ForkJoin, of } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
const concatJson = (path) => path.concat('.json');
const PATH_TEMPLATE_REGEX = /{([^}]+)}/gi;
const PATH_CLEAN_REGEX = /([^:]\/)\/+/gi;
const DEFAULT_PATH_TEMPLATE = '{baseTranslateUrl}/{moduleName}/{language}';
export class ModuleTranslateLoader {
    /**
     * The ModuleTranslateLoader for 'ngx-translate/core'
     *
     * @description Fetch multiple translation files (http).
     *
     * @param http the HttpClient from 'angular/common'
     * @param options the configurable options for ModuleTranslateLoader
     *
     * @see https://github.com/larscom/ngx-translate-module-loader
     */
    constructor(http, options) {
        this.http = http;
        this.options = options;
        this.defaultOptions = {
            disableNamespace: false,
            lowercaseNamespace: false,
            deepMerge: true,
            ...this.options
        };
    }
    getTranslation(language) {
        const { defaultOptions: options } = this;
        return this.mergeTranslations(this.getModuleTranslations(language, options), options);
    }
    mergeTranslations(moduleTranslations, { deepMerge, translateMerger }) {
        return ForkJoin(moduleTranslations).pipe(map((translations) => {
            return translateMerger
                ? translateMerger(translations)
                : deepMerge
                    ? mergeAll(translations)
                    : translations.reduce((acc, curr) => ({ ...acc, ...curr }), Object());
        }));
    }
    getModuleTranslations(language, options) {
        const { modules } = options;
        return modules.map((module) => {
            const { moduleName } = module;
            return moduleName
                ? this.fetchTranslationForModule(language, options, module)
                : this.fetchTranslation(language, options, module);
        });
    }
    fetchTranslation(language, { translateError, version }, { pathTemplate, baseTranslateUrl, translateMap }) {
        const pathOptions = Object({ baseTranslateUrl, language });
        const template = pathTemplate || DEFAULT_PATH_TEMPLATE;
        const cleanedPath = concatJson(template.replace(PATH_TEMPLATE_REGEX, (_, m1) => pathOptions[m1] || '')).replace(PATH_CLEAN_REGEX, '$1');
        const path = version ? `${cleanedPath}?v=${version}` : cleanedPath;
        return this.http.get(path).pipe(map((translation) => (translateMap ? translateMap(translation) : translation)), this.catchError(cleanedPath, translateError));
    }
    fetchTranslationForModule(language, { disableNamespace, lowercaseNamespace, translateError, version }, { pathTemplate, baseTranslateUrl, moduleName, namespace, translateMap }) {
        const pathOptions = Object({ baseTranslateUrl, moduleName, language });
        const template = pathTemplate || DEFAULT_PATH_TEMPLATE;
        const namespaceKey = namespace
            ? namespace
            : lowercaseNamespace
                ? moduleName.toLowerCase()
                : moduleName.toUpperCase();
        const cleanedPath = concatJson(template.replace(PATH_TEMPLATE_REGEX, (_, m1) => pathOptions[m1] || '')).replace(PATH_CLEAN_REGEX, '$1');
        const path = version ? `${cleanedPath}?v=${version}` : cleanedPath;
        return this.http.get(path).pipe(map((translation) => {
            return translateMap
                ? translateMap(translation)
                : disableNamespace
                    ? translation
                    : Object({ [namespaceKey]: translation });
        }), this.catchError(cleanedPath, translateError));
    }
    catchError(path, translateError) {
        return catchError((e) => {
            if (translateError) {
                translateError(e, path);
            }
            console.error('Unable to load translation file:', path);
            return of(Object());
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kdWxlLXRyYW5zbGF0ZS1sb2FkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtdHJhbnNsYXRlLW1vZHVsZS1sb2FkZXIvc3JjL2xpYi9tb2R1bGUtdHJhbnNsYXRlLWxvYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsR0FBRyxJQUFJLFFBQVEsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM1QyxPQUFPLEVBQUUsUUFBUSxJQUFJLFFBQVEsRUFBd0MsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RGLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLakQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFFMUQsTUFBTSxtQkFBbUIsR0FBRyxhQUFhLENBQUM7QUFDMUMsTUFBTSxnQkFBZ0IsR0FBRyxlQUFlLENBQUM7QUFDekMsTUFBTSxxQkFBcUIsR0FBRyw0Q0FBNEMsQ0FBQztBQUUzRSxNQUFNLE9BQU8scUJBQXFCO0lBUWhDOzs7Ozs7Ozs7T0FTRztJQUNILFlBQTZCLElBQWdCLEVBQW1CLE9BQWtDO1FBQXJFLFNBQUksR0FBSixJQUFJLENBQVk7UUFBbUIsWUFBTyxHQUFQLE9BQU8sQ0FBMkI7UUFqQmpGLG1CQUFjLEdBQThCO1lBQzNELGdCQUFnQixFQUFFLEtBQUs7WUFDdkIsa0JBQWtCLEVBQUUsS0FBSztZQUN6QixTQUFTLEVBQUUsSUFBSTtZQUNmLEdBQUcsSUFBSSxDQUFDLE9BQU87U0FDaEIsQ0FBQztJQVltRyxDQUFDO0lBRS9GLGNBQWMsQ0FBQyxRQUFnQjtRQUNwQyxNQUFNLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQztRQUN6QyxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJ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YyxFQUFFO2dCQUNsQixjQUFjLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3pCO1lBRUQsT0FBTyxDQUFDLEtBQUssQ0FBQyxrQ0FBa0MsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN4RCxPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IFRyYW5zbGF0ZUxvYWRlciB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgYWxsIGFzIG1lcmdlQWxsIH0gZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCB7IGZvcmtKb2luIGFzIEZvcmtKb2luLCBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJTW9kdWxlVHJhbnNsYXRpb24gfSBmcm9tICcuL21vZGVscy9tb2R1bGUtdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgSU1vZHVsZVRyYW5zbGF0aW9uT3B0aW9ucyB9IGZyb20gJy4vbW9kZWxzL21vZHVsZS10cmFuc2xhdGlvbi1vcHRpb25zJztcbmltcG9ydCB7IFRyYW5zbGF0aW9uIH0gZnJvbSAnLi9tb2RlbHMvdHJhbnNsYXRpb24nO1xuXG5jb25zdCBjb25jYXRKc29uID0gKHBhdGg6IHN0cmluZykgPT4gcGF0aC5jb25jYXQoJy5qc29uJyk7XG5cbmNvbnN0IFBBVEhfVEVNUExBVEVfUkVHRVggPSAveyhbXn1dKyl9L2dpO1xuY29uc3QgUEFUSF9DTEVBTl9SRUdFWCA9IC8oW146XVxcLylcXC8rL2dpO1xuY29uc3QgREVGQVVMVF9QQVRIX1RFTVBMQVRFID0gJ3tiYXNlVHJhbnNsYXRlVXJsfS97bW9kdWxlTmFtZX0ve2xhbmd1YWdlfSc7XG5cbmV4cG9ydCBjbGFzcyBNb2R1bGVUcmFuc2xhdGVMb2FkZXIgaW1wbGVtZW50cyBUcmFuc2xhdGVMb2FkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRPcHRpb25zOiBJTW9kdWxlVHJhbnNsYXRpb25PcHRpb25zID0ge1xuICAgIGRpc2FibGVOYW1lc3BhY2U6IGZhbHNlLFxuICAgIGxvd2VyY2FzZU5hbWVzcGFjZTogZmFsc2UsXG4gICAgZGVlcE1lcmdlOiB0cnVlLFxuICAgIC4uLnRoaXMub3B0aW9uc1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgTW9kdWxlVHJhbnNsYXRlTG9hZGVyIGZvciAnbmd4LXRyYW5zbGF0ZS9jb3JlJ1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gRmV0Y2ggbXVsdGlwbGUgdHJhbnNsYXRpb24gZmlsZXMgKGh0dHApLlxuICAgKlxuICAgKiBAcGFyYW0gaHR0cCB0aGUgSHR0cENsaWVudCBmcm9tICdhbmd1bGFyL2NvbW1vbidcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciBNb2R1bGVUcmFuc2xhdGVMb2FkZXJcbiAgICpcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGFyc2NvbS9uZ3gtdHJhbnNsYXRlLW1vZHVsZS1sb2FkZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgaHR0cDogSHR0cENsaWVudCwgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBJTW9kdWxlVHJhbnNsYXRpb25PcHRpb25zKSB7fVxuXG4gIHB1YmxpYyBnZXRUcmFuc2xhdGlvbihsYW5ndWFnZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbj4ge1xuICAgIGNvbnN0IHsgZGVmYXVsdE9wdGlvbnM6IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2VUcmFuc2xhdGlvbnModGhpcy5nZXRNb2R1bGVUcmFuc2xhdGlvbnMobGFuZ3VhZ2UsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgbWVyZ2VUcmFuc2xhdGlvbnMoXG4gICAgbW9kdWxlVHJhbnNsYXRpb25zOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uPltdLFxuICAgIHsgZGVlcE1lcmdlLCB0cmFuc2xhdGVNZXJnZXIgfTogSU1vZHVsZVRyYW5zbGF0aW9uT3B0aW9uc1xuICApOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uPiB7XG4gICAgcmV0dXJuIEZvcmtKb2luKG1vZHVsZVRyYW5zbGF0aW9ucykucGlwZShcbiAgICAgIG1hcCgodHJhbnNsYXRpb25zKSA9PiB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVNZXJnZXJcbiAgICAgICAgICA/IHRyYW5zbGF0ZU1lcmdlcih0cmFuc2xhdGlvbnMpXG4gICAgICAgICAgOiBkZWVwTWVyZ2VcbiAgICAgICAgICA/IG1lcmdlQWxsPFRyYW5zbGF0aW9uPih0cmFuc2xhdGlvbnMpXG4gICAgICAgICAgOiB0cmFuc2xhdGlvbnMucmVkdWNlKChhY2MsIGN1cnIpID0+ICh7IC4uLmFjYywgLi4uY3VyciB9KSwgT2JqZWN0KCkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRNb2R1bGVUcmFuc2xhdGlvbnMobGFuZ3VhZ2U6IHN0cmluZywgb3B0aW9uczogSU1vZHVsZVRyYW5zbGF0aW9uT3B0aW9ucyk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24+W10ge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gb3B0aW9ucztcblxuICAgIHJldHVybiBtb2R1bGVzLm1hcCgobW9kdWxlKSA9PiB7XG4gICAgICBjb25zdCB7IG1vZHVsZU5hbWUgfSA9IG1vZHVsZTtcbiAgICAgIHJldHVybiBtb2R1bGVOYW1lXG4gICAgICAgID8gdGhpcy5mZXRjaFRyYW5zbGF0aW9uRm9yTW9kdWxlKGxhbmd1YWdlLCBvcHRpb25zLCBtb2R1bGUpXG4gICAgICAgIDogdGhpcy5mZXRjaFRyYW5zbGF0aW9uKGxhbmd1YWdlLCBvcHRpb25zLCBtb2R1bGUpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBmZXRjaFRyYW5zbGF0aW9uKFxuICAgIGxhbmd1YWdlOiBzdHJpbmcsXG4gICAgeyB0cmFuc2xhdGVFcnJvciwgdmVyc2lvbiB9OiBJTW9kdWxlVHJhbnNsYXRpb25PcHRpb25zLFxuICAgIHsgcGF0aFRlbXBsYXRlLCBiYXNlVHJhbnNsYXRlVXJsLCB0cmFuc2xhdGVNYXAgfTogSU1vZHVsZVRyYW5zbGF0aW9uXG4gICk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24+IHtcbiAgICBjb25zdCBwYXRoT3B0aW9ucyA9IE9iamVjdCh7IGJhc2VUcmFuc2xhdGVVcmwsIGxhbmd1YWdlIH0pO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gcGF0aFRlbXBsYXRlIHx8IERFRkFVTFRfUEFUSF9URU1QTEFURTtcblxuICAgIGNvbnN0IGNsZWFuZWRQYXRoID0gY29uY2F0SnNvbihcbiAgICAgIHRlbXBsYXRlLnJlcGxhY2UoUEFUSF9URU1QTEFURV9SRUdFWCwgKF8sIG0xOiBzdHJpbmcpID0+IHBhdGhPcHRpb25zW20xXSB8fCAnJylcbiAgICApLnJlcGxhY2UoUEFUSF9DTEVBTl9SRUdFWCwgJyQxJyk7XG5cbiAgICBjb25zdCBwYXRoID0gdmVyc2lvbiA/IGAke2NsZWFuZWRQYXRofT92PSR7dmVyc2lvbn1gIDogY2xlYW5lZFBhdGg7XG5cbiAgICByZXR1cm4gdGhpcy5odHRwLmdldDxUcmFuc2xhdGlvbj4ocGF0aCkucGlwZShcbiAgICAgIG1hcCgodHJhbnNsYXRpb24pID0+ICh0cmFuc2xhdGVNYXAgPyB0cmFuc2xhdGVNYXAodHJhbnNsYXRpb24pIDogdHJhbnNsYXRpb24pKSxcbiAgICAgIHRoaXMuY2F0Y2hFcnJvcihjbGVhbmVkUGF0aCwgdHJhbnNsYXRlRXJyb3IpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZmV0Y2hUcmFuc2xhdGlvbkZvck1vZHVsZShcbiAgICBsYW5ndWFnZTogc3RyaW5nLFxuICAgIHsgZGlzYWJsZU5hbWVzcGFjZSwgbG93ZXJjYXNlTmFtZXNwYWNlLCB0cmFuc2xhdGVFcnJvciwgdmVyc2lvbiB9OiBJTW9kdWxlVHJhbnNsYXRpb25PcHRpb25zLFxuICAgIHsgcGF0aFRlbXBsYXRlLCBiYXNlVHJhbnNsYXRlVXJsLCBtb2R1bGVOYW1lLCBuYW1lc3BhY2UsIHRyYW5zbGF0ZU1hcCB9OiBJTW9kdWxlVHJhbnNsYXRpb25cbiAgKTogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbj4ge1xuICAgIGNvbnN0IHBhdGhPcHRpb25zID0gT2JqZWN0KHsgYmFzZVRyYW5zbGF0ZVVybCwgbW9kdWxlTmFtZSwgbGFuZ3VhZ2UgfSk7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBwYXRoVGVtcGxhdGUgfHwgREVGQVVMVF9QQVRIX1RFTVBMQVRFO1xuXG4gICAgY29uc3QgbmFtZXNwYWNlS2V5ID0gbmFtZXNwYWNlXG4gICAgICA/IG5hbWVzcGFjZVxuICAgICAgOiBsb3dlcmNhc2VOYW1lc3BhY2VcbiAgICAgID8gbW9kdWxlTmFtZSEudG9Mb3dlckNhc2UoKVxuICAgICAgOiBtb2R1bGVOYW1lIS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgY29uc3QgY2xlYW5lZFBhdGggPSBjb25jYXRKc29uKFxuICAgICAgdGVtcGxhdGUucmVwbGFjZShQQVRIX1RFTVBMQVRFX1JFR0VYLCAoXywgbTE6IHN0cmluZykgPT4gcGF0aE9wdGlvbnNbbTFdIHx8ICcnKVxuICAgICkucmVwbGFjZShQQVRIX0NMRUFOX1JFR0VYLCAnJDEnKTtcblxuICAgIGNvbnN0IHBhdGggPSB2ZXJzaW9uID8gYCR7Y2xlYW5lZFBhdGh9P3Y9JHt2ZXJzaW9ufWAgOiBjbGVhbmVkUGF0aDtcblxuICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0PFRyYW5zbGF0aW9uPihwYXRoKS5waXBlKFxuICAgICAgbWFwKCh0cmFuc2xhdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlTWFwXG4gICAgICAgICAgPyB0cmFuc2xhdGVNYXAodHJhbnNsYXRpb24pXG4gICAgICAgICAgOiBkaXNhYmxlTmFtZXNwYWNlXG4gICAgICAgICAgPyB0cmFuc2xhdGlvblxuICAgICAgICAgIDogT2JqZWN0KHsgW25hbWVzcGFjZUtleV06IHRyYW5zbGF0aW9uIH0pO1xuICAgICAgfSksXG4gICAgICB0aGlzLmNhdGNoRXJyb3IoY2xlYW5lZFBhdGgsIHRyYW5zbGF0ZUVycm9yKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGNhdGNoRXJyb3I8VD4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIHRyYW5zbGF0ZUVycm9yPzogKGVycm9yOiBhbnksIHBhdGg6IHN0cmluZykgPT4gdm9pZFxuICApOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xuICAgIHJldHVybiBjYXRjaEVycm9yKChlKSA9PiB7XG4gICAgICBpZiAodHJhbnNsYXRlRXJyb3IpIHtcbiAgICAgICAgdHJhbnNsYXRlRXJyb3IoZSwgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBsb2FkIHRyYW5zbGF0aW9uIGZpbGU6JywgcGF0aCk7XG4gICAgICByZXR1cm4gb2YoT2JqZWN0KCkpO1xuICAgIH0pO1xuICB9XG59XG4iXX0=